sysvinit
========
http://download.savannah.nongnu.org/releases/sysvinit/

The project home is on http://savannah.nongnu.org/projects/sysvinit .

和 System V 相兼容的, system V 风格的 init 系统

内核初始化的最后一步就是启动 pid 为 1 的 init 进程。这个进程是系统的第一个进程。
它负责产生其他所有用户进程。
init 以守护进程方式存在，是所有其他进程的祖先。init 进程非常独特，能够完成其他进程无法完成的任务。
Init 系统能够定义、管理和控制 init 进程的行为。

三个主要的 Init 系统：sysvinit，UpStart 和 systemd
主要依赖于 Shell 脚本，这就决定了它的最大弱点：启动太慢。

运行级别
--------
Sysvinit 用术语 runlevel 来定义"预订的运行模式"。Sysvinit 检查 '/etc/inittab'
文件中是否含有 'initdefault' 项。 这告诉 init 系统是否有一个默认运行模式。如
果没有默认的运行模式，那么用户将进入系统控制台，手动决定进入何种运行模式。

log: "Thu Jan  1INIT: Entering runlevel: 5"

sysvinit 中运行模式描述了系统各种预订的运行模式。通常会有 8 种运行模式，即运行模式 0 到 6 和 S 或者 s。

每种 Linux 发行版对运行模式的定义都不太一样。但 0，1，6 却得到了大家的一致赞同：
    0 关机
    1 单用户模式
    6 重启

sysvinit 运行顺序
-----------------
Sysvinit 巧妙地用脚本，文件命名规则和软链接来实现不同的 runlevel。首先，
sysvinit 需要读取/etc/inittab 文件。分析这个文件的内容，它获得以下一些配置信息：

    系统需要进入的 runlevel
    捕获组合键的定义
    定义电源 fail/restore 脚本
    启动 getty 和虚拟控制台

得到配置信息后，sysvinit 顺序地执行以下这些步骤，从而将系统初始化为预订的 runlevel X。
    /etc/rc.d/rc.sysinit
    /etc/rc.d/rc 和/etc/rc.d/rcX.d/ (X 代表运行级别 0-6)
    /etc/rc.d/rc.local
    X Display Manager（如果需要的话）

首先，运行 rc.sysinit 以便执行一些重要的系统初始化任务。在 RedHat 公司的 RHEL5 中(RHEL6 已经使用 upstart 了)，rc.sysinit 主要完成以下这些工作。

    激活 udev 和 selinux
    设置定义在/etc/sysctl.conf 中的内核参数
    设置系统时钟
    加载 keymaps
    使能交换分区
    设置主机名(hostname)
    根分区检查和 remount
    激活 RAID 和 LVM 设备
    开启磁盘配额
    检查并挂载所有文件系统
    清除过期的 locks 和 PID 文件

完成了以上这些工作之后，sysvinit 开始运行/etc/rc.d/rc 脚本。根据不同的 runlevel，rc 脚本将打开对应该 runlevel 的 rcX.d 目录(X 就是 runlevel)，找到并运行存放在该目录下的所有启动脚本。每个 runlevel X 都有一个这样的目录，目录名为/etc/rc.d/rcX.d。

在这些目录下存放着很多不同的脚本。文件名以 S 开头的脚本就是启动时应该运行的脚本，S 后面跟的数字定义了这些脚本的执行顺序。在/etc/rc.d/rcX.d 目录下的脚本其实都是一些软链接文件，真实的脚本文件存放在/etc/init.d 目录下。如下所示：
清单 1.rc5.d 目录下的脚本
1
2
3
4
5
6
7
8
9
10
11
12
	
[root@www ~]# ll /etc/rc5.d/
lrwxrwxrwx 1 root root 16 Sep  4  2008 K02dhcdbd -> ../init.d/dhcdbd
....(中间省略)....
lrwxrwxrwx 1 root root 14 Sep  4  2008 K91capi -> ../init.d/capi
lrwxrwxrwx 1 root root 23 Sep  4  2008 S00microcode_ctl -> ../init.d/microcode_ctl
lrwxrwxrwx 1 root root 22 Sep  4  2008 S02lvm2-monitor -> ../init.d/lvm2-monitor
....(中间省略)....
lrwxrwxrwx 1 root root 17 Sep  4  2008 S10network -> ../init.d/network
....(中间省略)....
lrwxrwxrwx 1 root root 11 Sep  4  2008 S99local -> ../rc.local
lrwxrwxrwx 1 root root 16 Sep  4  2008 S99smartd -> ../init.d/smartd
....(底下省略)....

当所有的初始化脚本执行完毕。Sysvinit 运行/etc/rc.d/rc.local 脚本。

rc.local 是 Linux 留给用户进行个性化设置的地方。您可以把自己私人想设置和启动的东西放到这里，一台 Linux Server 的用户一般不止一个，所以才有这样的考虑。


Sysvinit 和系统关闭
-------------------
Sysvinit 不仅需要负责初始化系统，还需要负责关闭系统。在系统关闭时，为了保证数据的一致性，需要小心地按顺序进行结束和清理工作。

比如应该先停止对文件系统有读写操作的服务，然后再 umount 文件系统。否则数据就会丢失。

这种顺序的控制这也是依靠/etc/rc.d/rcX.d/目录下所有脚本的命名规则来控制的，在该目录下所有以 K 开头的脚本都将在关闭系统时调用，字母 K 之后的数字定义了它们的执行顺序。

这些脚本负责安全地停止服务或者其他的关闭工作。

Sysvinit 的管理和控制功能
-------------------------
此外，在系统启动之后，管理员还需要对已经启动的进程进行管理和控制。原始的 sysvinit 软件包包含了一系列的控制启动，运行和关闭所有其他程序的工具。

halt

停止系统。

init

这个就是 sysvinit 本身的 init 进程实体，以 pid1 身份运行，是所有用户进程的父进程。最主要的作用是在启动过程中使用/etc/inittab 文件创建进程。

killall5

就是 SystemV 的 killall 命令。向除自己的会话(session)进程之外的其它进程发出信号，所以不能杀死当前使用的 shell。

last

回溯/var/log/wtmp 文件(或者-f 选项指定的文件)，显示自从这个文件建立以来，所有用户的登录情况。

lastb

作用和 last 差不多，默认情况下使用/var/log/btmp 文件，显示所有失败登录企图。

mesg

控制其它用户对用户终端的访问。

pidof

找出程序的进程识别号(pid)，输出到标准输出设备。

poweroff

等于 shutdown -h –p，或者 telinit 0。关闭系统并切断电源。

reboot

等于 shutdown –r 或者 telinit 6。重启系统。

runlevel

读取系统的登录记录文件(一般是/var/run/utmp)把以前和当前的系统运行级输出到标准输出设备。

shutdown

以一种安全的方式终止系统，所有正在登录的用户都会收到系统将要终止通知，并且不准新的登录。

sulogin

当系统进入单用户模式时，被 init 调用。当接收到启动加载程序传递的-b 选项时，init 也会调用 sulogin。

telinit

实际是 init 的一个连接，用来向 init 传送单字符参数和信号。

utmpdump

以一种用户友好的格式向标准输出设备显示/var/run/utmp 文件的内容。

wall

向所有有信息权限的登录用户发送消息。

不同的 Linux 发行版在这些 sysvinit 的基本工具基础上又开发了一些辅助工具用来简化 init 系统的管理工作。比如 RedHat 的 RHEL 在 sysvinit 的基础上开发了 initscripts 软件包，包含了大量的启动脚本 (如 rc.sysinit) ，还提供了 service，chkconfig 等命令行工具，甚至一套图形化界面来管理 init 系统。其他的 Linux 发行版也有各自的 initscript 或其他名字的 init 软件包来简化 sysvinit 的管理。

只要您理解了 sysvinit 的机制，在一个最简的仅有 sysvinit 的系统下，您也可以直接调用脚本启动和停止服务，手动创建 inittab 和创建软连接来完成这些任务。因此理解 sysvinit 的基本原理和命令是最重要的。您甚至也可以开发自己的一套管理工具。

Sysvinit 的小结
---------------

Sysvinit 的优点是概念简单。Service 开发人员只需要编写启动和停止脚本，概念非常清楚；将 service 添加/删除到某个 runlevel 时，只需要执行一些创建/删除软连接文件的基本操作；这些都不需要学习额外的知识或特殊的定义语法(UpStart 和 Systemd 都需要用户学习新的定义系统初始化行为的语言)。

其次，sysvinit 的另一个重要优点是确定的执行顺序：脚本严格按照启动数字的大小顺序执行，一个执行完毕再执行下一个，这非常有益于错误排查。UpStart 和 systemd 支持并发启动，导致没有人可以确定地了解具体的启动顺序，排错不易。

但是串行地执行脚本导致 sysvinit 运行效率较慢，在新的 IT 环境下，启动快慢成为一个重要问题。此外动态设备加载等 Linux 新特性也暴露出 sysvinit 设计的一些问题。针对这些问题，人们开始想办法改进 sysvinit，以便加快启动时间，并解决 sysvinit 自身的设计问题。

Upstart 是第一个被广泛应用的新一代 init 系统。我们在接下来的第二部分介绍 UpStart。
=================
rda600: 
/etc/inittab: init(8) configuration.

(1) /etc/init.d/rcS (This is run first)

(2)	Source defaults.
/etc/default/rcS

(3) Call all parts in order.
exec /etc/init.d/rc S

(4)
		# Now run the START scripts for this runlevel.
		# Run all scripts with the same level in parallel
		for s in /etc/rc$runlevel.d/S*
/etc/rc5.d/
/etc/rcS.d/ ?

